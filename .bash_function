# vim: ft=sh
#
# ~/.bash_function
#

EC() {
    printf " \e[01;33m"%3.d"\e[m " $?
}

calc() {
    python3 -c "print($*)"
#    echo "scale=3;$@" | bc -l
}

yis() {
    yi -s "$(echo "$*" | tr '\n' ' ')"
}
mkcd() {
	mkdir "$@" && cd "$_"
}

alarm() {
	date +%F_%T
	sleep ${1}m
	espeak "$1 miutes" &>/dev/null
	date +%F_%T
	bell 4
}

cl() {
	cd "$1" && l
}

cdd() {
    cd $(dirname $1)
}

incognitoshell() {
    if [[ -z $(echo $SHELLOPTS | grep -o history) ]]; then
        set -o history
        echo -e incognito: '\e[1;33m'off
    else
        set +o history
        echo -e incognito: '\e[1;33m'on
    fi
}

proxyshell() {
    if [[ $http_proxy == 127.0.0.1:8787 ]]; then
        unset http_proxy && unset https_proxy
        echo -e proxy: '\e[1;33m'off
    else
        export http_proxy=127.0.0.1:8787 && export https_proxy=$http_proxy
        echo -e proxy: '\e[1;33m'on
    fi
}

langswitch() {
	if [[ $LANG == zh_CN.UTF-8 ]]; then
		export LANGUAGE=en_US && export LANG=en_US.UTF-8
		echo -e language: '\e[1;33m'en
	else
		export LANGUAGE=zh_CN:en_US && export LANG=zh_CN.UTF-8
		echo -e language: '\e[1;33m'zh
	fi
}

new() {
	roxterm -e bash -c "$1;exec bash" &>/dev/null
}

i3-save-tree-function() {
	i3-save-tree --workspace $1 | tail -n +2 | fgrep -v "// splitv" | fgrep -v "// splith" | fgrep -v "// tabbed" | sed "s|//||g" > ~/.config/i3/workspace-$1.json
}

tempaliases() {
	if [[ $1 == e ]]; then
		vim ~/.bash_aliases.temp
	else
		source ~/.bash_aliases.temp
	fi
}

gitpull() {
local gitdir gitrepo
for gitdir in $@; do
	for gitrepo in `ls -p $gitdir | grep "/$"`; do
		cd $gitdir/$gitrepo
		pwd
		git pull
        separatedLine
	done
done
[[ $# == 0 ]] && gitpull ~/git
}

tarc() {
_usage() {
echo "\
Usage: tarc [ARCHIVE] [FILE]...
   or: tarc [FORMAT] [FILE]...

compress FILEs
  -h, --help            display this help and exit

example: 
  tarc ~/backup/bash.7z ~/.bash{rc,_aliases,_function,_profile}
  tarc tar.gz ../file1 ../../file2 /tmp/file3
"
}
[[ $1 == "-h" || $1 == "--help" ]] && _usage && return
[[ $# == 0 ]] && _usage && return
local format=$1
local name=${2%/}
if [ $# -gt 2 ]; then
    name=$name-$(randomstr 6)
fi
shift
case $format in
    zip              ) zip -qr    "$name".$format "$@" ;;
    rar              ) rar a -idq "$name".$format "$@" ;;
    7z               ) 7z a -bso0 "$name".$format "$@" ;;
    tar              ) tar -cf    "$name".$format "$@" ;;
    tgz |tar.gz      ) tar -czf   "$name".$format "$@" ;;
    tbz2|tar.bz2     ) tar -cjf   "$name".$format "$@" ;;
    tar.xz           ) tar -cJf   "$name".$format "$@" ;;
    gz               ) gzip -k    "$@"                 ;;
    bz2              ) bzip2 -kz  "$@"                 ;;
    xz               ) xz -kz     "$@"                 ;;
    *.zip            ) zip -qr    $format "$@"         ;;
    *.rar            ) rar a -idq $format "$@"         ;;
    *.7z             ) 7z a -bso0 $format "$@"         ;;
    *.tar            ) tar -cf    $format "$@"         ;;
    *.tgz |*.tar.gz  ) tar -czf   $format "$@"         ;;
    *.tbz2|*.tar.bz2 ) tar -cjf   $format "$@"         ;;
    *.tar.xz         ) tar -cJf   $format "$@"         ;;
    *.gz             ) gzip -c    "$1" > $format       ;;
    *.bz2            ) bzip2 -cz  "$1" > $format       ;;
    *.xz             ) xz -cz     "$1" > $format       ;;
    *                ) tar -czf   "$name".tar.gz  "$@" ;;
esac
}

tarx() {
_usage() {
echo "\
Usage: tarx [FILE]...
decompress FILEs
  -h, --help            display this help and exit"
}
[[ $1 == "-h" || $1 == "--help" ]] && _usage && return
[[ $# == 0 ]] && _usage && return
local j file basename
for j in $(seq $#); do
    file=$(realpath -s "$1")
    shift
    basename=$(basename "$file")
    mkcd "$basename.tarx"
    case "$file" in
        # *.t@(gz|lz|xz|b@(2|z?(2))|a@(z|r?(.@(Z|bz?(2)|gz|lzma|xz)))) ) bsdtar xvf $file;;
        *.zip            ) unzip -q     "$file" ;; # || unzip -O gbk -q "$file" ;;
        *.rar            ) unrar x -idq "$file" ;;
        *.7z             ) 7z x         "$file" ;;
        *.tar            ) tar -xf      "$file" ;;
        *.tgz |*.tar.gz  ) tar -xzf     "$file" ;;
        *.tbz2|*.tar.bz2 ) tar -xjf     "$file" ;;
        *.tar.xz         ) tar -xJf     "$file" ;;
        *.gz             ) gzip -kd     "$file" ;;
        *.bz2            ) bzip2 -kd    "$file" ;;
        *.xz             ) xz -kd       "$file" ;;
        *                ) echo         "$file" cannot be extracted >&2 ;;
    esac
    cd ../
    rmdir --ignore-fail-on-non-empty "$basename.tarx"
    separatedLine
done
}

paclfb() {
    pacman -Ql $1 | grep -E "/usr/bin/.+" | cut -d/ -f4
}

paclfs() {
    pacman -Ql $1 | grep -Ee "\.service$" -e "\.socket$" -e "\.timer$" | cut -d" " -f2
}

gpg-verify() {
    local sig=$1
    local gpg=$2.gpg
    local RSA=$(gpg --verify $sig 2>&1 | grep RSA | awk '{print $5}')
    echo RSA=$RSA

    gpg --no-default-keyring --keyring $gpg --keyserver https://pgp.mit.edu --recv-keys $RSA
    #gpg --no-default-keyring --keyring $gpg --keyserver hkp://keys.gnupg.net --recv-keys $RSA
    separatedLine
    gpg --verify --verbose --keyring ~/.gnupg/$gpg $sig
}

you-get-play() {
    you-get --format=mp4 --player ${2:-smplayer} "$1" || you-get --player ${2:-smplayer} "$1"
}

gitup() {
    local commitMessage="timeline"
    [[ -n "$1" ]] && commitMessage="$1"

    git add --all
    git commit --message="$commitMessage"
    git push
}

insh() {
_usage() {
echo 'Usage: insh [command]...
execution the command after entering the parameter
  \${KEY}               specify a placeholder
  -h, --help            display this help and exit'
}
[[ $1 == "-h" || $1 == "--help" ]] && _usage && return
[[ $# == 0 ]] && _usage && return
local KEY
if [[ "$*" == *\${KEY}* ]]; then
    while true; do
        echo -ne '\e[1;32m'$@' \e[0m'
        read -e KEY
        eval $@
        separatedLine
    done
else
    while true; do
        echo -ne '\e[1;32m'$@' \e[0m'
        read -e KEY
        eval $@ $KEY
        separatedLine
    done
fi
}

loop() {
_usage() {
echo "\
Usage: loop [count] -s[sleep-time] [command]...
loop execution the command
  -s[sleep-time]        after sleep time execution command,default 0
  -h, --help            display this help and exit"
}
[[ $1 == "-h" || $1 == "--help" ]] && _usage && return
[[ $# == 0 ]] && _usage && return
if [[ "$2" == -s* ]]; then
    local sleeptime=$(echo $2 | cut -c 3-)
    for i in $(seq $1); do
        if [ $i -ne 1 ]; then
            sleep $sleeptime
        fi
        eval ${@:3}
        separatedLine
    done
else
    for i in $(seq $1); do
        eval ${@:2}
        separatedLine
    done
fi
}

aliased() {
    local aliasStr=$(type $1 | cut -d\` -f2)
    echo ${aliasStr%\'*}
}

shacheck() {
local CMD BYTE=$(echo -n $2 | wc -c)
case $BYTE in
32  ) CMD=md5sum   ;;
40  ) CMD=sha1sum  ;;
56  ) CMD=sha224sum;;
64  ) CMD=sha256sum;;
96  ) CMD=sha384sum;;
128 ) CMD=sha512sum;;
esac

$CMD "$1" | grep -i $2 &>/dev/null && echo $1: OK || echo $1: FAILED
}

pidoff() {
local pid
if ! pid=$(pgrep $1); then return 2; fi
if [[ $(echo $pid | wc -w) != 1 ]]; then
    local line tmpfile=$(mktemp)
    ps -o args,user,tname,%cpu,%mem,stat $pid > $tmpfile
    echo -n "      	"; head -n1 $tmpfile; sed -i 1d $tmpfile; nl -s ". " $tmpfile
    read -p 'Type a line number to check: ' -n $(wc -l < $tmpfile | wc -L) line
    rm $tmpfile
    pid=(0 $pid); pid=${pid[$line]}
    echo
fi
echo 'run in background: [Ctrl + c], !!&'
while ps $pid &>/dev/null ; do
    sleep 2
done
bell 2
notify-send --app-name=$1 --expire-time=0 "$1 is over."
}

linkfind() {
#find symbolic: 只能找到目标(target)是文件的实际路径(realpath)的
#find hard    : 文件所在是用--bind挂载的会出错
local i inode exclude path file="$(realpath "$1")"
if [[ $(stat --format=%h "$file") == 1 ]]; then
    echo find symbolic link
    path="${2:-/}"
    find "$path" -path /proc -prune -o -lname "$file" -print
else
    echo find hard link
    inode=$(stat --format=%i "$file")
    path=${2:-$(df -a --output=target "$file" | sed -n 2p)}
    if exclude=$(df -a --output=target | grep "$path.\+"); then
        find $path $(for i in $exclude; do echo -n "-path $i -prune -o "; done) -inum $inode -print
    else
        find "$path" -inum "$inode" -print
    fi
fi
}

# Syntax-highlight JSON strings or files
json() {
    if [ -t 0 ]; then # argument
        python -mjson.tool <<< "$*" | pygmentize -l javascript
    else # pipe
        python -mjson.tool | pygmentize -l javascript
    fi
}

# UTF-8-encode a string of Unicode symbols
escape() {
    printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo
    fi
}

# Decode \x{ABCD}-style Unicode escape sequences
unidecode() {
    perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo
    fi
}

codepoint() {
    perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi
}

# Show all the names (CNs and SANs) listed in the SSL certificate for a given domain
getcertnames() {
    if [ -z "${1}" ]; then
        echo "ERROR: No domain specified."
        return 1
    fi

    local domain="${1}"
    echo "Testing ${domain}…"
    echo ""; # newline

    local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
        | openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1)

    if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
        local certText=$(echo "${tmp}" \
            | openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
            no_serial, no_sigdump, no_signame, no_validity, no_version")
        echo "Common Name:"
        echo ""; # newline
        echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//"
        echo ""; # newline
        echo "Subject Alternative Name(s):"
        echo ""; # newline
        echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
            | sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2
        return 0
    else
        echo "ERROR: Certificate not found."
        return 1
    fi
}

treee() {
    tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

dataurl() {
    local mimeType=$(file -b --mime-type "$1");
    if [[ $mimeType == text/* ]]; then
        mimeType="${mimeType}";
        #mimeType="${mimeType};charset=utf-8";
    fi
    echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
}


#-----------------------------------------------------------
hl() {
#H_COLORS_FG="bold black on_rgb520","bold red on_rgb025"
#H_COLORS_BG="underline bold rgb520","underline bold rgb025"
    _usage() {
        echo "usage: YOUR_COMMAND | hl [-idn] args...
    -i : ignore case
    -d : disable regexp
    -n : invert colors"
    }

    local _OPTS

    # detect pipe or tty
    if [[ -t 0 ]]
	then
        _usage
        return
    fi

    # manage flags
    while getopts ":idnQ" opt; do
        case $opt in
            i) _OPTS+=" -i " ;;
            d)  _OPTS+=" -Q " ;;
            n) n_flag=true ;;
            Q)  _OPTS+=" -Q " ;;
                # let's keep hidden compatibility with -Q for original ack users
            \?) _usage
                return ;;
        esac
    done

    shift $(($OPTIND - 1))

    # set zsh compatibility
    [[ -n $ZSH_VERSION ]] && setopt localoptions && setopt ksharrays && setopt ignorebraces

    local _i=0

    if [[ -n $H_COLORS_FG ]]; then
        local _CSV="$H_COLORS_FG"
        local OLD_IFS="$IFS"
        IFS=','
        local _COLORS_FG=()
        for entry in $_CSV; do
          _COLORS_FG=("${_COLORS_FG[@]}" "$entry")
        done
        IFS="$OLD_IFS"
    else
        _COLORS_FG=(
                "underline bold red" \
                "underline bold green" \
                "underline bold yellow" \
                "underline bold blue" \
                "underline bold magenta" \
                "underline bold cyan"
                )
    fi

    if [[ -n $H_COLORS_BG ]]; then
        local _CSV="$H_COLORS_BG"
        local OLD_IFS="$IFS"
        IFS=','
        local _COLORS_BG=()
        for entry in $_CSV; do
          _COLORS_BG=("${_COLORS_BG[@]}" "$entry")
        done
        IFS="$OLD_IFS"
    else
        _COLORS_BG=(
                "bold on_red" \
                "bold on_green" \
                "bold black on_yellow" \
                "bold on_blue" \
                "bold on_magenta" \
                "bold on_cyan" \
                "bold black on_white"
                )
    fi

    if [[ -z $n_flag ]]; then
        #inverted-colors-last scheme
        _COLORS=("${_COLORS_FG[@]}" "${_COLORS_BG[@]}")
    else
        #inverted-colors-first scheme
        _COLORS=("${_COLORS_BG[@]}" "${_COLORS_FG[@]}")
    fi

    if [[ "$#" -gt ${#_COLORS[@]} ]]; then
        echo "You have passed to hhighlighter more keywords to search than the number of configured colors.
Check the content of your H_COLORS_FG and H_COLORS_BG environment variables or unset them to use default 12 defined colors."
        return 1
    fi

    if [ -n "$ZSH_VERSION" ]; then
       local WHICH="whence"
    else [ -n "$BASH_VERSION" ]
       local WHICH="type -P"
    fi

    if ! ACKGREP_LOC="$($WHICH ack-grep)" || [ -z "$ACKGREP_LOC" ]; then
        if ! ACK_LOC="$($WHICH ack)" || [ -z "$ACK_LOC" ]; then
            echo "ERROR: Could not find the ack or ack-grep commands"
            return 1
        else
            local ACK=$($WHICH ack)
        fi
    else
        local ACK=$($WHICH ack-grep)
    fi

    # build the filtering command
    for keyword in "$@"
    do
        local _COMMAND=$_COMMAND"$ACK $_OPTS --noenv --flush --passthru --color --color-match=\"${_COLORS[$_i]}\" '$keyword' |"
        _i=$_i+1
    done
    #trim ending pipe
    _COMMAND=${_COMMAND%?}
    #echo "$_COMMAND"
    cat - | eval $_COMMAND

}
